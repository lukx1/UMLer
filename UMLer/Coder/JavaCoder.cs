using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UMLer.DiagramData;
using UMLer.Paintables;

namespace UMLer.Coder
{
    public class JavaCoder : ICoder
    {
        public Language CodingLanguage => Language.CSHARP;

        public string OutputDirectory { get; set; } = "";
        public Diagram Diagram { get; set; }

        public JavaCoder(Diagram diagram)
        {
            this.Diagram = Diagram;
        }

        private const string CSHARP_FILE_CLASS_HEADER = 
            "/* AUTOMATICALLY GENERATED BY UMLer */\r\n";

        private string GetAccessModCore(AccessModifier accessModifier)
        {
            switch (accessModifier)
            {
                case AccessModifier.PUBLIC:
                case AccessModifier.PROTECTED:
                case AccessModifier.PRIVATE:
                    return accessModifier.ToString().ToLower() + " ";
                default:
                case AccessModifier.NONE:
                    return "";
            }
        }

        private string GetExtraMods(IList<ExtraModifier> em)
        {
            StringBuilder builder = new StringBuilder();
            foreach (var mod in em)
            {
                if (builder.Length > 0)
                    builder.Append(" ");
                builder.Append(mod.ToString().ToLower());
            }
            if (em.Count > 0)
                builder.Append(" ");
            return builder.ToString();
        }

        private void WriteFields(StreamWriter writer, Clazz clazz)
        {
            foreach (var field in clazz.Fields)
            {
                writer.WriteLine(
                    $"\t" +
                    $"{GetAccessModCore(field.AccessModifier)}" +
                    $"{GetExtraMods(field.ExtraModifiers)}" +
                    $"{field.Type} " +
                    $"{field.Name};");
            }
        }

        private void WriteMethods(StreamWriter writer, Clazz clazz)
        {
            foreach (var method in clazz.Methods)
            {
                writer.WriteLine(
                    $"\t" +
                    $"{GetAccessModCore(method.AccessModifier)}" +
                    $"{GetExtraMods(method.ExtraModifiers)}" +
                    $"{method.ReturnType} " +
                    $"{method.Name}({method.ParametersToSyntax()})\r\n" +
                    "\t{\r\n" +
                    "\t\tthrow new UnsupportedOperationException(\"Not implemented yet\");\r\n" +
                    "\t}"
                    );
            }
        }

        private void WriteClass(StreamWriter writer, Clazz clazz)
        {
            writer.WriteLine($"" +
                    $"{GetAccessModCore(clazz.AccessModifier)}" +
                    $"{GetExtraMods(clazz.ExtraModifiers)}" +
                    $"class " +
                    $"{clazz.Name} " + "{\r\n");
        }

        private void CreateClass(Clazz clazz)
        {
            var resultPath = Path.Combine(OutputDirectory, clazz.Name + ".cs");
            using (var writer = new StreamWriter(resultPath))
            {
                writer.Write(CSHARP_FILE_CLASS_HEADER);
                WriteClass(writer, clazz);
                WriteFields(writer, clazz);
                writer.Write("\r\n");
                WriteMethods(writer, clazz);
                writer.WriteLine("}");
            }
        }

        public void CreateCode()
        {
            if (!Directory.Exists(OutputDirectory))
                throw new DirectoryNotFoundException($"Directory {OutputDirectory} does not exist");
            if (Diagram == null)
                throw new NullReferenceException("Diagram hasn't been set");

            var clazzes = Diagram.PullAllClazzes();
            foreach (var clazz in clazzes)
            {
                CreateClass(clazz);
            }
        }

        public bool AreClazzesValid()
        {
            var classes = Diagram.ElementPanel.Paintables.OfType<DiagramClass>().ToList();
            List<string> classNames = new List<string>();
            foreach (var clazz in classes)
            {
                classNames.Add(clazz.RepresentingClass.Name);
            }
            if (classNames.Count != classNames.Distinct().Count())
                return false;
            return true;
        }

    }
}
